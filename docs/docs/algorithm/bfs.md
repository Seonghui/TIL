---
layout: default
title: BFS
parent: algorithm
nav_order: 1
---

# BFS

BFS는 그래프 전체를 탐색하는 방법 중의 하나로, 루트 노드\(혹은 다른 임의의 노드\)에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다. BFS의 목적은 임의의 정점에서 시작해서 모든 정점을 한 번씩 방문하는 것이다. 이를 구현하기 위해서는 선입선출\(FIFO\)을 원칙으로 하는 큐\(Queue\)를 사용한다. 일반적으로 큐를 이용해서 반복적인 형태로 구현하는 것이 가장 잘 동작한다.

## Queue로 BFS를 구현하는 방법

1. Queue의 가장 앞에 있는 노드를 Pop
2. 현재 노드에 인접한 모든 노드들 중 아직 방문하지 않은 노드들을 Queue에 Push
3. Queue가 비어있지 않으면 1번부터 다시 실행

여기서 push는 나중에 방문할 노드를 저장하는 것이고, pop은 front에 있는 노드를 방문하는 것이다. 이 논리구조를 간략하게 나타내면,

```text
while(Queue가 비어있지 않은 동안) {
  1. queue의 가장 앞에 있는 노드를 pop
  2. 현재 노드에 인접한 모든 노드들 중 아직 방문하지 않은 노드들을 Queue에 Push
}
```

## 문제

### 로봇 청소기

* 최소 거리를 구하는 거니까 BFS로 구할 수 있음
* 칸을 이동할 때는 한 번으로 셈
* 모든 최단거리는 시작점이 1개일 때 다른 모든 거리의 최단거리를 구하는 알고리즘임. 그 말은 시작점이 고정이 되면 최단거리를 여러 번 구할 필요가 없음. 하지만 이 문제는 시작점이 한 개가 아님.
* 더러운 칸의 개수는 10개를 넘지 않는다 조건 때문에 BFS로 구할 수 있음. 경우의 수는 10!

### 레이저 통신

* 가중치를 의미하는 건 선분의 갯수
* 가중치는 0 아니면 1

### 0과 1

* 경우의 수가 많아서 브루트 포스로는 안 됨

### 점프 게임

* 이동방법은 총 3개
* 앞으로 뒤로 다른 칸으로 점프
* 거리가 -1이면 이미 방문한 곳임
* 이동할 수 없으면 0 이동할 수 있으면 1
* 내가 이동하려는 칸보다 최소시간이 크면 못 가는 칸이라고 처리

[https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html](https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html) [https://sarah950716.tistory.com/13](https://sarah950716.tistory.com/13)

