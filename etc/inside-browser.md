# inside-browser

### 브라우저 내부 살펴보기

브라우저가 HTML을 해석하고 화면에 나타내는 방법은 HTML,CSS 표준에 따르게 되는데, 브라우저에 따라 스펙 정의가 좀 다를 수도 있음

## 시작하기 전 용어 설명

컴퓨터나 스마트폰 애플리케이션을 실행할 때 애플리케이션을 구동하는 것이 바로 CPU와 GPU다.

* CPU: 컴퓨터의 두뇌
* GPU: 간단한 작업에만 특화되어 잇지만 여러 GPU 코어가 동시에 작업을 수행할 수 있음. 그래픽 작업 처리를 위해 개발되었다.
* 프로세스: 애플리케이션이 실행하는 프로그램
* 스레드: 프로세스 내부에 있으며 프로세스로 실행되는 프로그램의 일부

## 브라우저 아키텍쳐 \(Chromium 기준\)

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_1-08.png) 1. 브라우저 프로세스: 주소 표시줄, 북마크 막대, 뒤로 가기 버튼, 앞으로 가기 버튼 등을 제어한다. 네트워크 요청이나 파일 접근과 같이 눈에 보이지는 않지만 권한이 필요한 부분도 처리한다. 2. 렌더러 프로세스: 탭 안에서 웹 사이트가 표시되는 부분의 모든 것을 제어한다. 예전 렌더러 프로세스는 여러 개가 만들어져 각 탭마다 할당되었지만, 지금은 사이트마다 프로세스를 할당한다. 3. 플러그인 프로세스: 웹 사이트에서 사용하는 플러그인\(예: Flash\)을 제어한다. 4. GPU 프로세스: GPU 작업을 다른 프로세스와 격리해서 처리한다. GPU는 여러 애플리케이션의 요청을 처리하고 같은 화면에 요청받은 내용을 그리기 때문에 GPU 프로세스는 별도 프로세스로 분리되어 있다. 5. 기타 프로세스: 확장 프로그램 프로세스, 유틸리티 프로세스 등의 프로세스가 있음.

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_1-09.png)

## 1. 브라우저 프로세스

* 브라우저 프로세스는 탭 영역 밖에 있는 모든 부분을 제어한다.
* 브라우저의 주소 표시줄에 URL을 입력하면 브라우저가 인터넷에서 데이터를 가져와서 페이지를 표시한다. 간단한 이 동작에서 사용자가 사이트를 요청하고 브라우저가 페이지 렌더링을 준비하는 과정\(이 글에서는 이 과정을 '내비게이션'이라고 하겠다\)에 초점을 맞춰 살펴보겠다.

### 브라우저 프로세스의 구성요소 \(스레드\)

다른 것들도 있지만 본문은 세가지만 언급했음

* UI 스레드: 브라우저의 버튼과 입력란을 그림. 렌더러 프로세스를 먼저 찾거나 네트워크 요청과 동시에 렌더러 프로세스를 시작한다.
* 네트워크 스레드: 인터넷에서 데이터를 가져오기 위한 스택을 다룸
* 스토리지 스레드: 파일에 대한 접근을 제어

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-01.png)

### 내비게이션 처리방법

내비게이션 처리를 대강 요약하자면 아래와 같다.

1. 입력 처리: 주소 표시줄에 URL 입력. UI 스레드가 검색어인지 쿼리인지 판별.
2. 내비게이션 시작: URL 입력하고 엔터키 누르면서 시작. UI 스레드가 네트워크 호출 시작.
3. 응답 읽기: 호출하고 나서 응답 본문이 들어오면 그 응답을 읽음
4. 렌더러 프로세스 찾기: 응답을 읽고 각 형식에 따라 적당한 렌더러 프로세스를 찾음 \(HTML이면 렌더러 프로세스, ZIP이면 다운로드 매니저\)
5. 내비게이션 실행: 데이터와 렌더러 프로세스가 전부 준비된 상태. 문서 로딩하면서 브라우저 프로세스도 업데이트 \(주소 표시줄, 뒤로 가기 버튼 등등\)
6. 로드 완료: 렌더러 프로세스는 계속 리소스를 로딩하고 페이지 렌더링. 끝내면 브라우저 프로세스로 IPC 메시지를 보냄 

> 여기서 IPC 메시지란 프로세스간 통신\(Inter-Process Communication, IPC\) 메시지를 의미한다.

#### 1. 입력 처리

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-02.png)

* 주소 표시줄에 타이핑을 시작하면 UI 스레드가 검색어\(search query\)인지 URL인지 확인. 
* 입력되는 내용을 파싱해서 검색 엔진으로 이동할지 요청한 사이트로 이동할지 결정함.

#### 2. 내비게이션 시작

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-03.png)

* 사용자가 Enter 키를 누르면 사이트의 콘텐츠를 가져오기 위해 UI 스레드가 네트워크 호출을 시작한다. 
* 로딩 스피너가 탭의 모서리에 표시되고, 네트워크 스레드는 요청에 대한 DNS Lookup 및 TLS 연결 설정과 같은 적절한 프로토콜을 거쳐 요청을 처리한다. 
* 요청을 처리할 때 네트워크 스레드가 HTTP 301과 같은 서버 리디렉션 헤더를 수신할 수도 있다. 그런 경우에는 **네트워크 스레드가 UI 스레드와 통신해 서버가 리디렉션을 요청했다는 것을 알린다.** 그런 다음 새로운 URL 요청이 시작된다.

#### 3. 응답 읽기

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-04.png)

* 응답 본문인 페이로드가 들어오기 시작하면 네트워크 스레드는 필요에 따라 스트림의 처음 몇 바이트를 확인한다. 페이로드가 어떤 형식의 데이터인지는 응답 헤더의 Content-Type 헤더가 알려 주지만 정보가 없거나 잘못된 정보가 있을 수 있다. 그래서 이때 MIME 스니핑을 실행해 데이터의 실제 형식을 알아낸다. Chromium 소스 코드의 주석에 적힌 것처럼 데이터의 실제 형식을 알아내는 것은 '까다로운 작업'\(tricky business\)이다. 이 주석을 보면 브라우저가 얼마나 다양한 방법으로 Content-Type 헤더와 페이로드를 처리하는지 알 수 있을 것이다. 
* 만약 응답이 HTML 파일이면 데이터를 **렌더러 프로세스**에 전달하는 단계로 넘어가고, 응답이 ZIP 형식이나 다른 형식의 파일이라면 다운로드 요청이므로 **다운로드 매니저**에 데이터를 전달하는 단계로 넘어간다. \(다시 말해 렌더러 프로세스가 다룰 수 있는 데이터 형식인지, 다룰 수 없는 데이터 형식인지로 구분한다.\) 
* 이 단계에서는 Safe Browsing 검사가 실행된다. \(도메인과 응답 데이터가 악성 사이트로 알려진 사이트와 일치하면 네트워크 스레드는 경고 페이지를 표시하라고 알림\)

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-05.png)

#### 4. 렌더러 프로세스 찾기

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-06.png)

* 모든 검사가 끝나고 브라우저가 요청된 사이트로 이동해야 한다고 네트워크 스레드가 확신하게 되면 네트워크 스레드는 UI 스레드에 데이터가 준비되었음을 알린다. 그러면 UI 스레드는 **웹 페이지의 렌더링을 수행할 렌더러 프로세스를 찾는다**.
* 이 과정에서는 네트워크 요청이 응답을 받기까지 수백 밀리초가 걸릴 수 있기 때문에 이 과정을 더 빨리 진행하기 위한 최적화가 적용되어 있다. \(2단계에서 UI스레드가 URL요청을 보낼 때 UI 스레드는 이미 어느 사이트로 이동할지 알고 있다. 따라서 네트워크 스레드가 데이터를 받을 때 이미 렌더러 프로세스는 준비 상태에 있게 된다. 하지만 리다이렉션의 경우 다른 프로세스가 필요하게 되면 미리 준비한 프로세스가 사용되지 않을 수도 있다.\)

#### 5. 내비게이션 실행

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-07.png)

* 데이터와 렌더러 프로세스가 준비되었으므로 내비게이션을 실행하도록 브라우저 프로세스에서 렌더러 프로세스로 IPC 메시지를 전송한다. 
* 또한 렌더러 프로세스가 HTML 데이터를 계속 수신할 수 있도록 브라우저 프로세스는 데이터 스트림을 전달한다. 
* 렌더러 프로세스에서 내비게이션이 실행되었다는 것을 브라우저 프로세스가 확인하고 나면 내비게이션이 완료되고 문서 로딩 단계가 시작된다.
* 이 시점에 주소 표시줄이 업데이트되고 보안 표시와 사이트 설정 UI도 새 페이지의 사이트 정보를 반영해 갱신된다. 
* 탭에 대한 세션 기록이 업데이트되어 뒤로 가기 버튼과 앞으로 가기 버튼도 방금 이동한 사이트를 반영해 작동한다. 
* 탭이나 창을 닫은 이후 탭과 세션을 복원할 수 있게 세션 기록이 디스크 드라이브에 저장된다.

#### 6. 로드 완료

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-08.png)

* 내비게이션이 실행되면 렌더러 프로세스는 계속 리소스를 로딩하고 페이지를 렌더링한다.
* 렌더러 프로세스가 렌더링을 '끝내면' 브라우저 프로세스로 IPC 메시지를 보낸다\(이 시점은 페이지의 모든 프레임에서 onload 이벤트의 실행까지 끝낸 이후이다\). 그러면 UI 스레드는 탭에서 로딩 스피너의 작동을 중지한다.

#### 추가. 다른 사이트로 내비게이션

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-09.png)

간단한 내비게이션이 완료되었다. 그런데 사용자가 주소 표시줄에 다른 URL을 다시 입력하면 어떻게 될까? 브라우저 프로세스는 동일한 단계를 거쳐 다른 사이트로 이동을 처리한다. 하지만 그전에 현재 렌더링된 사이트에서 `beforeunload` 이벤트를 확인해야 한다. `beforeunload` 이벤트는 탭을 닫거나 이동하려고 할 때 "이 사이트를 떠나시겠습니까?"라는 경고창을 만들 수 있다. JavaScript 코드를 포함해 탭 안의 모든 것은 렌더러 프로세스에 의해 처리되므로 브라우저 프로세스는 새로운 내비게이션 요청이 들어오면 현재 렌더러 프로세스를 확인해야 한다. \(내비게이션 요청은 렌더러 프로세스-&gt;브라우저 프로세스로 넘어간다\)

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-10.png)

#### 추가. 서비스 워커

![](https://d2.naver.com/content/images/2019/03/helloworld-201903-sangwoo-ko_2-12.png)

* 서비스 워커는 애플리케이션의 코드에 네트워크 프락시를 작성할 수 있는 수단이다.
* 서비스 워커를 통해 웹 개발자는 무엇을 로컬 캐시에 저장할지, 언제 네트워크에서 새 데이터를 가져올지 제어할 수 있다.
* 서비스 워커가 캐시에서 페이지를 로드하도록 설정되었다면 네트워크에서 데이터를 가져오도록 요청할 필요가 없다.
* 기억해야 할 중요한 점은 서비스 워커가 렌더러 프로세스에서 실행되는 JavaScript 코드라는 점이다. 
* 서비스 워커가 등록되면 서비스 워커의 범위는 참조로 유지된다. 내비게이션이 발생하면 네트워크 스레드는 도메인을 등록된 서비스 워커의 범위와 비교한다. 해당 URL에 등록된 서비스 워커가 있으면 UI 스레드는 서비스 워커 코드를 실행하기 위해 렌더러 프로세스를 찾는다. 서비스 워커는 네트워크에 데이터를 요청하지 않고 캐시에서 데이터를 가져올 수 있다. 또는 네트워크에 새 리소스를 요청할 수도 있다.
* 웹페이지와는 별개로 작동한다. 예를 들어 푸시 알림, 백그라운드 동기화와 같은 기능이 바로 서비스 워커인데 최신 기술이므로 Browser compatibility 확인하자.. 그리고 더 알고싶으면 [문서](https://developers.google.com/web/fundamentals/primers/service-workers/?hl=ko) 읽어보기

### 다중 프로세스 아키텍처가 크롬에 주는 이점

* 크롬은 렌더러 프로세스를 여러 개 사용한다.
* 한 탭이 응답하지 않아 종료되더라도 다른 탭은 유지 가능 \(만약 모든 탭이 하나의 프로세스에서 실행되는 경우 탭이 하나만 응답하지 않더라도 모든 탭이 응답하지 못하게 됨\)
* 보안과 격리를 할 수 있음. 운영체제를 통해 프로세스의 권한을 제어할 수 있어 브라우저는 특정 프로세스가 특정 기능을 사용할 수 없게 제한
* 프로세스 개수가 한도에 다다르면 동일한 사이트를 열고 있는 여러 탭을 하나의 프로세스에서 처리

## 2. 렌더러 프로세스

![](https://d2.naver.com/content/images/2019/04/helloworld-201904-sangwoo-ko_3-01.png)

* 탭 내부에서 발생하는 모든 작업\(웹 콘텐츠\)을 처리.
* 주요 역할은 HTML과 CSS, 자바스크립트를 사용자와 상호작용할 수 있는 웹페이지로 변환하는 것.
* 렌더러 프로세스의 메인 스레드가 브라우저로 전송된 대부분의 코드를 처리하는데, 간혹 웹 워커나 서비스 워커를 사용하는 경우에는 워커 스레드가 자바스크립트의 코드 일부를 처리한다.

### 렌더링 처리방법

렌더링 처리를 대강 요약하자면 아래와 같다.

1. 파싱: 문자열\(HTML\)을 파싱해서 DOM으로 변환
2. 하위 리소스 로딩: 이미지, CSS, JavaScript와 같은 외부 리소스 로딩
3. 스타일 계산: 각 DOM 노드에 계산된 스타일을 확정
4. 레이아웃: 메인 스레드가 DOM과 계산된 스타일을 훑어가며 레이아웃 트리 생성
5. 페인트: 페인트 기록\(paint record\)을 생성하기 위해 레이아웃 트리를 순회. 그래서 뭐 먼저 그려야할지 지록함.
6. 합성: 문서의 구조와 각 요소의 스타일, 요소의 기하학적 속성, 페인트 순서 등의 정보를 합쳐 픽셀로 변환 \(래스터화\)

#### 1. 파싱

* 페이지를 이동하라는 메시지를 렌더러 프로세스가 받으고 HTML 데이터를 수신하기 시작하면 렌더러 프로세스의 메인 스레드는 문자열\(HTML\)을 파싱해서 DOM\(document object model\)으로 변환하기 시작한다.
* HTML 문서를 DOM으로 파싱하는 방법은 HTML 표준에 정의되어 있다.

#### 2. 하위 리소스 로딩

* 웹 사이트는 일반적으로 이미지, CSS, JavaScript와 같은 외부 리소스를 사용한다. 이러한 파일은 네트워크나 캐시에서 로딩해야 한다. DOM을 구축하기 위해 파싱하는 동안 이런 리소스를 만날 때마다 메인 스레드가 하나하나 요청할 수도 있을 것이다. 
* 하지만 속도를 높이기 위해 '프리로드\(Preload\) 스캐너'가 동시에 실행된다. HTML 문서에 `<img>` 또는 `<link>` 와 같은 태그가 있으면 프리로드 스캐너는 HTML 파서가 생성한 토큰을 확인하고 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다.
* 자바스크립트는 파싱을 막을 수 있다. `<script>` 태그를 만나면 HTML 파서는 HTML 문서의 파싱을 일시 중지한 다음 자바스크립트 코드를 로딩하고 파싱해 실행해야 한다. 왜냐면 자바스크립트는 DOM 구조를 바꿀 수 있어 문서의 모양을 변경할 수 있기 때문이다. HTML 파싱을 재개하기 전에 HTML 파서는 자바스크립트의 실행이 끝나기를 기다려야 한다.
* 리소스가 어떻게 로딩하길 원하는지 브라우저에 힌트를 줄 수 있다. 예를 들면 script를 로딩할 때 async 속성이나 defer 속성이 있다.

![](https://d2.naver.com/content/images/2019/04/helloworld-201904-sangwoo-ko_3-02.png)

#### 3. 스타일 계산

* DOM만으로는 웹 페이지의 모양을 알 수 없다. CSS로 웹 페이지 요소의 모양을 결정할 수 있기 때문이다. 메인 스레드는 CSS를 파싱하고 각 DOM 노드에 해당되는 계산된 스타일\(computed style\)을 확정한다. 계산된 스타일은 CSS 선택자\(selector\)로 구분되는 요소에 적용될 스타일에 관한 정보이다. 개발자 도구의 computed 패널에서 이 정보를 볼 수 있다.
* CSS를 전혀 적용하지 않아도 DOM 노드에는 계산된 스타일이 적용되어 있다. \(브라우저 기본 스타일이 있기 때문. [Chromium 소스 코드의 html.css 파일](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/html/resources/html.css) 참고.\)

![](https://d2.naver.com/content/images/2019/04/helloworld-201904-sangwoo-ko_3-03.png)

#### 4. 레이아웃

* 메인 스레드는 DOM과 계산된 스타일을 훑어가며 레이아웃 트리를 만든다. 
* 레이아웃 트리는 x, y 좌표, 박스 영역\(bounding box\)의 크기와 같은 정보를 가지고 있다.

> 알아두면 좋은 것 - 레이아웃 트리는 DOM 트리와 비슷한 구조일 수 있지만 웹 페이지에 보이는 요소에 관련된 정보만 가지고 있다. display: none 속성이 적용된 요소는 레이아웃 트리에 포함되지 않는다\(그러나 visibility: hidden 속성이 적용된 요소는 레이아웃 트리에 포함된다\). 이와 비슷하게 p::before{content:"Hi!} 속성과 같은 의사 클래스\(pseudo class\)의 콘텐츠는 DOM에는 포함되지 않지만 레이아웃 트리에는 포함된다.

![](https://d2.naver.com/content/images/2019/04/helloworld-201904-sangwoo-ko_3-05.png)

#### 5. 페인트

* DOM, 스타일, 레이아웃을 가지고도 여전히 페이지를 렌더링할 수 없다. 그림을 하나 따라 그리려고 한다고 생각해 보자. 요소의 크기, 모양, 위치를 알더라도 어떤 순서로 그려야 할지 판단해야 한다.
* 예를 들어 어떤 요소에 z-index 속성이 적용되었다면 HTML에 작성된 순서로 요소를 그리면 잘못 렌더링된 화면이 나온다.
* 페인트 단계에서 메인 스레드는 페인트 기록\(paint record\)을 생성하기 위해 레이아웃 트리를 순회한다. 페인트 기록은 '배경 먼저, 다음은 텍스트, 그리고 직사각형'과 같이 페인팅 과정을 기록한 것이다. \(퍼포먼스탭에서 볼수있는듯?\)

![](https://d2.naver.com/content/images/2019/04/helloworld-201904-sangwoo-ko_3-09.png)

#### 6. 합성

![](https://d2.naver.com/content/images/2019/04/helloworld-201904-sangwoo-ko_3-14.gif)

* 문서의 구조와 각 요소의 스타일, 요소의 기하학적 속성, 페인트 순서를 알고 있는 상태
* 여기서 하는 건 이 정보를 화면의 픽셀로 변환하는 작업을 래스터화\(rasterizing\)라고 한다.
* 가장 단순한 래스터화는 아마 뷰포트 안쪽을 래스터하는 것일 것이다. 사용자가 웹 페이지를 스크롤하면 이미 래스터화한 프레임을 움직이고 나머지 빈 부분을 추가로 래스터화한다. 이 방식은 Chrome이 처음 출시되었을 때 래스터화한 방식이다. 그러나 최신 브라우저는 **합성\(compositing\)**이라는 보다 정교한 과정을 거친다. 여기서는 CPU보다 GPU가 더 많이 사용된다.
* 합성은 웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화하고 컴포지터 스레드\(compositor thread\)라고 하는 별도의 스레드에서 웹 페이지로 합성하는 기술이다.
* 스크롤되었을 때 레이어는 이미 래스터화되어 있으므로 새 프레임을 합성하기만 하면 된다. 애니메이션 역시 레이어를 움직이고 합성하는 방식으로 만들 수 있다. \(레이어는 크롬 개발자도구 -&gt; 옵션 -&gt; more tools에서 선택 가능. 자세한 정보는 [여기](https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752) 클릭.\)

#### 추가. 여러 레이어로 나눠서 합성하기

이건 읽어도 뭔 소린지 1도 모르겠습니다. [본문](https://d2.naver.com/helloworld/5237120) 여러 레이어로 나누기부터 참고.

## refs

* [https://d2.naver.com/helloworld/2922312](https://d2.naver.com/helloworld/2922312)
* [윗글 원문 링크](https://developers.google.com/web/updates/2018/09/inside-browser-part1)
* [https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752](https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752)

